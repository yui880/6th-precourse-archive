# 프리코스 공통 피드백 

## 1️⃣ 1주 차 
### 📍 요구사항을 정확히 준수한다.
과제 제출 전에 기능 요구 사항, 프로그래밍 요구 사항, 과제 진행 요구 사항의 항목을 모두 잘 지켰는지 다시 한 번 점검한다. 

### 📍 커밋 메세지를 의미있게 작성한다.
커밋 메세지에 해당 커밋에서 작업한 내용에 대한 이해가 가능하도록 작성한다.

### 📍 git을 통해 관리할 자원에 대해서도 고려한다.
`node_modules` 는 `package.json` 파일이 있으면 설치할 수 있고 버전 관리를 직접 하지 않으므로 git으로 관리하지 않아도 된다.
Intellij의 `.idea` 폴더, VS Code의 `.vscode` 폴더 또한 개발 도구가 자동으로 생성하는 폴더이기 때문에 굳이 git으로 관리하지 않아도 된다.
앞으로 git에 코드를 추가할 때는 git을 통해 관리할 필요가 있는지를 고려해볼 것을 추천한다.

### 📍 Pull Request를 보내기 전 브랜치를 확인한다.
기능 구현 작업을 fork된 Repository의 main branch가 아닌, 기능 구현을 위해 새로 만든 브랜치에서 작업한 후 PR을 보낸다. 

### 📍 PR을 한 번 작성했다면 닫지 말고 추가 커밋을 한다.
PR을 이미 한 번 보냈다면, 새로운 PR을 생성할 필요가 없다. 
수정이 필요하다면 추가 커밋을 하면 자동으로 반영된다. 단, 미션 제출 기간 이후에는 추가 커밋을 하지 않는다.

### 📍 이름을 통해 의도를 드러낸다.
나 자신, 다른 개발자와의 소통을 위해 가장 중요한 활동 중의 하나가 좋은 이름 짓기이다. 
변수 이름, 함수(메서드) 이름, 클래스 이름을 짓는데 시간을 투자하라. 
이름을 통해 변수의 역할, 함수의 역할, 클래스의 역할에 대한 의도를 드러내기 위해 노력하라. 
연속된 숫자를 덧붙이거나(a1, a2, ..., aN), 불용어(Info, Data, a, an, the)를 추가하는 방식은 적절하지 못하다.

### 📍 축약하지 않는다
의도를 드러낼 수 있다면 이름이 길어져도 괜찮다.
    누구나 실은 클래스, 메서드, 또는 변수의 이름을 줄이려는 유혹에 곧잘 빠지곤 한다. 
    그런 유혹을 뿌리쳐라. 축약은 혼란을 야기하며, 더 큰 문제를 숨기는 경향이 있다. 
    클래스와 메서드 이름을 한 두 단어로 유지하려고 노력하고 문맥을 중복하는 이름을 자제하자. 
    클래스 이름이 Order라면 shipOrder라고 메서드 이름을 지을 필요가 없다. 
    짧게 ship()이라고 하면 클라이언트에서는 order.ship()라고 호출하며, 간결한 호출의 표현이 된다.
    - 객체 지향 생활 체조 원칙 5: 줄여쓰지 않는다 (축약 금지)

### 📍 공백도 코딩 컨벤션이다.
if, for, while문 사이의 공백도 코딩 컨벤션이다.

### 📍 공백 라인을 의미 있게 사용한다.
공백 라인을 의미 있게 사용하는 것이 좋아 보이며, 문맥을 분리하는 부분에 사용하는 것이 좋다. 과도한 공백은 다른 개발자에게 의문을 줄 수 있다.

### 📍 space와 tab을 혼용하지 않는다
들여쓰기에 space와 tab을 혼용하지 않는다. 둘 중에 하나만 사용한다. 
확신이 서지 않으면 pull request를 보낸 후 들여쓰기가 잘 되어 있는지 확인하는 습관을 들인다.

### 📍 의미 없는 주석을 달지 않는다.
변수 이름, 함수(메서드) 이름을 통해 어떤 의도인지가 드러난다면 굳이 주석을 달지 않는다. 
모든 변수와 함수에 주석을 달기보다 가능하면 이름을 통해 의도를 드러내고, 의도를 드러내기 힘든 경우 주석을 다는 연습을 한다.

### 📍 linter와 Code Formatter의 기능을 활용한다
가능하면 eslint와 prettier를 이용해 더욱 생산적으로 코드를 작성하자.
린트(lint)는 소스 코드에 문제가 있는지 탐색하는 작업을 의미하며, 린터(linter)는 이 작업을 도와주는 소프트웨어를 말한다. 
자바스크립트와 같은 인터프리터 언어의 경우, 런타임 에러가 발생할 확률이 높기 때문에, 이 린트 작업을 통해 사전에 에러를 최대한 잡아준다면 훨씬 생산성 높은 개발을 할 수 있다. 
lint 중 eslint는 자바스크립트 진영의 오픈소스로 확장되고 있는 정적 분석 도구이다.
prettier는 일종의 Code Formatter이다. Code Formatter란 개발자가 작성한 코드가 정해진 코딩 스타일을 따르도록 변환해주는 도구이다. 
이 두 가지 도구를 이용하면 코드를 짜는데 발생할 수 있는 오류를 미리 예방하고 쉽게 정돈할 수 있다.

### 📍 EOL(End Of Line)
최종 제출하는 코드에서 EOL을 확인한다. 환경에 따라 의도한 바와 다르게 개행 문자 처리가 되지 않도록 EOL 설정을 확인한다.

### 📍 불필요한 console.log를 남기지 않는다.
디버깅을 위해 사용한 console.log가 최종 제출하는 코드에 의미 없이 남아있지 않도록 주의한다.

### 📍 JavaScript에서 제공하는 API를 적극 활용한다
함수(메서드)를 직접 구현하기 전에 JavaScript API에서 제공하는 기능인지 검색을 먼저 해본다.     
JavaScript API에서 제공하지 않을 경우에 직접 구현한다.
예를 들어 우승자를 출력할 때 우승자가 2명 이상이면 쉼표(,) 기준으로 출력을 위한 문자열은 다음과 같이 구현할 수 있다.

```js
const members = ['east', 'west', 'south'];
members.map((member) => member).join(','); // "east,west,south"
```


---
## 2️⃣ 2주 차 

### 📍 README.md를 상세히 작성한다.
미션 저장소의 README.md는 소스코드에 앞서 해당 프로젝트가 어떠한 프로젝트인지 마크다운으로 작성하여 소개하는 문서이다. 
해당 프로젝트가 어떠한 프로젝트이며, 어떤 기능을 담고 있는지 기술하기 위해서 마크다운 문법을 검색해서 학습해보고 적용해 본다.

### 📍 기능 목록을 재검토한다.
기능 목록을 클래스 설계와 구현, 함수(메서드) 설계와 구현과 같이 너무 상세하게 작성하지 않는다. 
클래스 이름, 함수(메서드) 시그니처와 반환값은 언제든지 변경될 수 있기 때문이다. 
너무 세세한 부분까지 정리하기보다 구현해야 할 기능 목록을 정리하는 데 집중한다. 
정상적인 경우도 중요하지만, 예외적인 상황도 기능 목록에 정리한다. 
특히 예외 상황은 시작 단계에서 모두 찾기 힘들기 때문에 기능을 구현하면서 계속해서 추가해 나간다.

### 📍 기능 목록을 업데이트한다.
README.md 파일에 작성하는 기능 목록은 기능 구현을 하면서 변경될 수 있다. 
시작할 때 모든 기능 목록을 완벽하게 정리해야 한다는 부담을 가지기보다 기능을 구현하면서 문서를 계속 업데이트한다. 
죽은 문서가 아니라 살아있는 문서를 만들기 위해 노력한다.

### 📍 값을 하드 코딩하지 않는다.
문자열, 숫자 등의 값을 하드 코딩하지 마라. 상수를 만들고 이름을 부여해 이 변수의 역할이 무엇인지 의도를 드러낸다.

### 📍 구현 순서도 코딩 컨벤션이다.
클래스는 필드, 생성자, 메서드 순으로 작성한다.
```js
class A {
    필드

    생성자

    메서드
}
```

### 📍 한 함수가 한 가지 기능만 담당하게 한다.
함수 길이가 길어진다면 한 함수에서 여러 일을 하려고 하는 경우일 가능성이 높다. 
아래와 같이 한 함수에서 안내 문구 출력, 사용자 입력, 유효값 검증 등 여러 일을 하고 있다면 이를 적절하게 분리한다.
```js
const userInput = () => {
  MissionUtils.Console.readLine("경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분): ", (input) => {
    const carNames = input.split(",");
    for (int index = 0; index < carNames.length; index++) {
      if (carNames[index].length < 1 || carNames[index].length > 5) {
        throw new Error("[ERROR] 자동차 이름은 1자 이상 5자 이하만 가능합니다.");
      }
    }
    return carNames;
  });
};
```

### 📍 함수가 한 가지 기능을 하는지 확인하는 기준을 세운다.
만약 여러 함수에서 중복되어 사용되는 코드가 있다면 함수 분리를 고민해 본다. 
또한, 함수의 길이를 15라인을 넘어가지 않도록 구현하며 함수를 분리하는 의식적인 연습을 할 수 있다.

### 📍 JavaScript에서 객체를 만드는 다양한 방법을 이해하고 사용한다.
JavaScript에서는 클래스 말고도 객체를 만드는 방법은 여러 가지가 있다. 
객체를 생성하는 방법에 대해서는 MDN 문서의 JavaScript 객체 기본과 Classes을 참고한다.

### 📍 테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다.
단지 기능을 점검하기 위한 목적으로 테스트를 작성하는 것은 아니다. 
테스트를 작성하는 과정을 통해서 나의 코드에 대해 빠르게 피드백을 받을 수 있을 뿐만 아니라 학습 도구(학습테스트를 통해 JUnit 학습하기.pdf)로도 활용할 수 있다. 
이런 경험을 통해 테스트에 대해 어떤 유용함을 느꼈는지 알아본다.

### 📍 처음부터 큰 단위의 테스트를 만들지 않는다
테스트의 중요한 목적 중 하나는 내가 작성하는 코드에 대해 빠르게 피드백을 받는 것이다. 
시작부터 큰 단위의 테스트를 만들게 된다면 작성한 코드에 대한 피드백을 받기까지 많은 시간이 걸린다. 
그래서 문제를 작게 나누고, 그 중 핵심 기능에 가까운 부분부터 작게 테스트를 만들어 나간다.

- 큰 단위의 테스트
  - 자동차경주를 시작해서 사용자가 이름, 진행 횟수를 입력하면, 게임을 진행한 후 그 결과를 알려준다.

- 작은 단위의 테스트
  - 무작위 값이 4 이상이면 자동차가 전진한다.
  - 무작위 값이 3 이하이면 자동차가 전진하지 않는다.


---
## 3️⃣ 3주 차 

### 📍 함수(메서드) 라인에 대한 기준 
프로그래밍 요구사항을 보면 함수 15라인으로 제한하는 요구사항이 있다. 
이때 공백 라인도 한 라인에 해당한다. 15라인이 넘어간다면 함수 분리를 위한 고민을 한다.

### 📍 발생할 수 있는 예외 상황에 대해 고민한다.
정상적인 경우를 구현하는 것보다 예외 상황을 모두 고려해 프로그래밍하는 것이 더 어렵다. 
예외 상황을 고려해 프로그래밍하는 습관을 들인다. 예를 들어 로또 미션의 경우 아래와 같은 예외 상황을 고민해 보고 해당 예외에 대해 처리를 할 수 있어야 한다.

- 로또 구입 금액에 1000 이하의 숫자를 입력
- 당첨 번호에 중복된 숫자를 입력
- 당첨 번호에 1~45 범위를 벗어나는 숫자를 입력
- 당첨 번호와 중복된 보너스 번호를 입력

### 📍 비즈니스 로직과 UI 로직을 분리한다.
비즈니스 로직과 UI 로직을 한 클래스가 담당하지 않도록 한다. 단일 책임의 원칙에도 위배된다.
```js
class Lotto {
   #numbers
    
   // 로또 숫자가 포함되어 있는지 확인하는 비즈니스 로직
   contains(numbers) {
       ...
   }

   // UI 로직
   print() {
       ...
   }      
   
}

```

### 📍 객체의 상태 접근을 제한한다.
필드는 private class 필드로 구현한다. 
객체의 상태를 외부에서 직접 접근하는 방식을 최소화 하는 이유에 대해서는 스스로 찾아본다.

### 📍 객체는 객체스럽게 사용한다.
Lotto 클래스는 numbers를 상태 값으로 가진다. 그런데 이 객체는 로직에 대한 구현은 하나도 없고, numbers에 대한 getter 메서드만을 가진다.
```js
class Lotto {
   #numbers


   constructor(numbers) {
       this.#numbers = numbers
   }


   getNumbers() {
       return this.#numbers
   }
}

class LottoGame {
   play() {
       const lotto = new Lotto(...)
       
       // 숫자가 포함되어 있는지 확인한다.
       lotto.getNumbers().contains(number)
       
       // 당첨 번호와 몇 개가 일치하는지 확인한다.
       lotto.getNumbers().stream()...
   }
}

```
Lotto에서 데이터를 꺼내지(get) 말고 메시지를 던지도록 구조를 바꿔 데이터를 가지는 객체가 일하도록 한다.

```js
class Lotto {
   #numbers

   constructor(numbers) {
       this.#numbers = numbers
   }

   contains(number) {
       // 숫자가 포함되어 있는지 확인한다.
       return ...
   }

   matchCount(other) {
       // 당첨 번호와 몇 개가 일치하는지 확인한다.
       return ...
   }
}

class LottoGame {
   play() {
       const lotto = new Lotto(...)
       
       lotto.contains(number)
       lotto.matchCount(...)
   }
}
```

### 📍 필드의 수를 줄이기 위해 노력한다.
필드의 수가 많은 것은 객체의 복잡도를 높이고, 버그 발생 가능성을 높일 수 있다. 필드에 중복이 있거나, 불필요한 필드가 없는지 확인해 필드의 수를 최소화한다.
예를 들어 총상금 및 수익률을 구하는 다음 객체를 보자.

```js
class LottoResult {
   #result = new Map()
   #profitRate
   #totalPrize
}
```

위 객체의 `profitRate`와 `totalPrize`는 등수 별 당첨 내역(`result`)만 있어도 모두 구할 수 있는 값이다. 
따라서 위 객체는 다음과 같이 하나의 필드만으로 구현할 수 있다.
```js
class LottoResult {
   #result = new Map()
    
   calculateProfitRate() { ... }
    
   calculateTotalPrize() { ... }
}

```

### 📍 성공하는 케이스 뿐만 아니라 예외에 대한 케이스도 테스트한다.
테스트를 작성하면 성공하는 케이스에 대해서만 고민하는 경우가 있다. 하지만 예외에 대한 부분 또한 처리해야 한다. 
특히 프로그램에서 결함이 자주 발생하는 부분 중 하나는 경계값이므로 이 부분을 꼼꼼하게 확인해야 한다.
```js
test("보너스 번호가 당첨 번호와 중복되는 경우에 대한 예외 처리", () => {
   mockQuestions( ["1000", "1,2,3,4,5,6", "6"]);
   expect(() => {
       const app = new App();
       app.play();
   }).toThrow("[ERROR]");
});
```

### 📍 테스트 코드도 코드다.
테스트 코드도 코드이므로 리팩터링을 통해 개선해 나가야 한다. 특히 반복적으로 하는 부분을 중복되지 않게 만들어야 한다. 
예를 들어 단순히 파라미터의 값만 바뀌는 경우라면 아래와 같이 테스트할 수 있다.
```js
test.each([["999"], ["0"], ["-123"]])("천원 미만의 금액에 대한 예외 처리", (input) => {
   expect(() => {
     const app = new App(input);
     app.play();
   }).toThrow();
 }
);
```

### 📍 테스트를 위한 코드는 구현 코드에서 분리되어야 한다.
테스트를 위한 편의 메서드를 구현 코드에 구현하지 마라. 아래의 예시처럼 테스트를 통과하기 위해 구현 코드를 변경하거나 테스트에서만 사용되는 로직을 만들지 않는다.

- 테스트를 위해 `# prefix`를 바꾸는 경우
- 테스트 코드에서만 사용되는 메서드

### 📍 단위 테스트하기 어려운 코드를 단위 테스트하기 
아래 코드는 `Random` 때문에 `Lotto`에 대한 단위 테스트를 하기 힘들다. 
단위 테스트가 가능하도록 리팩터링한다면 어떻게 하는 것이 좋을까?
```js
const MissionUtils = require("@woowacourse/mission-utils");

class Lotto {
   #numbers
    
   constructor() {
       this.#numbers = Randoms.pickUniqueNumbersInRange(1, 45, 6)
   }
}

class LottoMachine {
   execute() {
       const lotto = new Lotto()
   }
}

```
올바른 로또 번호가 생성되는 것을 테스트하기 어렵다. 테스트하기 어려운 것을 클래스 내부가 아닌 외부로 분리하는 시도를 해 본다.
```js
const MissionUtils = require("@woowacourse/mission-utils");

class Lotto {
   #numbers
    
   constructor(numbers) {
       this.#numbers = numbers
   }
}

class LottoMachine {
   execute() {
       const numbers = Randoms.pickUniqueNumbersInRange(1, 45, 6)
       const lotto = new Lotto(numbers)
   }
}
```
위 코드는 A 상황을 B로 바꾼 것이다.

A.
Application(테스트하기 어려움)<br/>
⬇️<br/>
LottoMachine(테스트하기 어려움)<br/>
⬇️<br/>
Lotto(테스트하기 어려움) ➡️ Randoms(테스트하기 어려움)


B.
Application(테스트하기 어려움)<br/>
⬇️<br/>
LottoMachine(테스트하기 어려움) ➡️ Randoms(테스트하기 어려움)<br/>
⬇️<br/>
Lotto(**테스트하기 쉬움**)

이처럼 단위 테스트를 할 때 테스트하기 어려운 부분은 분리하고 테스트 가능한 부분을 단위 테스트한다. 테스트하기 어려운 부분은 단위 테스트하지 않아도 된다. 남은 `LottoMachine`은 어떻게 테스트하기 쉽게 바꿀 수 있을지 고민해 본다.






